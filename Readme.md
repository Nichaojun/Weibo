# compute_simulation.py

使用 **Box-counting 算法** 来估计二维数据的 **分形维度**。通过计算不同大小的盒子内的数据点数量，并进行线性拟合，估计出数据的分形维度。

## 参数说明

1. **数据生成**：生成用户-话题矩阵，部分用户的发言固定，部分用户的发言为随机值, 其中m为话题数量，n为用户数量，同时M为矩阵内为nan的比例，J为极端用户（在两个不同的话题里面发表先完全相反的意见，分别为1和-1）
2. **Box-counting 算法**：根据不同的盒子大小（epsilon），计算包含数据点的盒子数量。
3. **维度估计**：对 `1/epsilon` 和箱子数量的对数进行线性拟合，得到箱子计数维度（分形维度）。
4. **并行计算**：使用多线程加速计算不同 `epsilon` 的箱子数量。
5. **结果保存与可视化**：保存结果到 `.txt` 文件，并生成 `.jpg` 图像显示对数图。

## 实验结果
1、但用户数目比较多的时候，只要观点是连续的，就基本无法计算，这个观点连续是指用户的观点在0-1之间都有分布。
2、极端用户对实验影响较大，且只要存在一个用户是极端的，就会导致最后算出来的维度比较高。


# compute_simulation_bisection.py

使用**二分法**和**Box-counting 算法** 来估计二维数据的 **分形维度**。然后，通过计算不同大小的盒子内的数据点数量，并进行线性拟合，估计出数据的分形维度。

## 参数说明

1. 参数和可视化如上
2. **二分计算**：因为eps和box数量是单调关系，所以可以使用二分来计算。
3. **Memory机制**：为了避免反复计算相同eps对应的box数目，对于每个eps和对应的box数目进行保存，每一次先查询Memory。
4. **精度问题**：二分最多计算五十次，超出五十次则直接返回None，因为在0-1之间，float类型只需要计算50次左右就达到了极限。


# 其他的python代码

只是更换了矩阵，其他保持不变。



# Output说明

## correlation_pooled_CGSS_new 和 correlation_pooled_GSS_new
文件夹下面分为year文件夹和year_bisection。分别表示不使用二分法和使用二分法。

## simulation 和 simulation_bisection
分别表示不使用二分法和使用二分法的结果

## tw和wb
在两个文件夹下有compute_tw_bisection.out和compute_wb_bisection.out分别表示两个在二分法中的结果。

```
15 0.505 1.0
15 0.7525 1.0
15 0.87625 1.0
15 0.938125 1.0
```
第一个数字表示目前想要找到的box数量，后面表示left和right，说明对应的eps一定在left和right之间。